<html>
<body>
    <h1>Release Notes</h1>
    <h3>What&#39;s new in 0.4</h3>
    <ul>
        <li>Improved book/chapter selection</li>
        <li>Recording now is delayed for 1/2 second to avoid recording sound of keyboard
            press.&nbsp; Wait for the record button to turn green before speaking.</li>
        <li>Improved recording level meter</li>
        <li>Indicator for confirming which microphone HearThis is recording from</li>
        <li>New &quot;Sample&quot; mode used if Paratext is not installed.</li>
    </ul>
    <h3>What&#39;s new in 0.3</h3>
    <ul>
        <li>Added publishing formatted for Saber, if LAME (mp3 encoder) is installed.</li>
        <li>Added publishing formatted for MegaVoice (see notes below)</li>
        <li>Added publishing to ogg format</li>
    </ul>
    <h3>What&#39;s new in 0.2</h3>
    <ul>
        <li>Added publishing to mp3s, if LAME is installed.</li>
    </ul>
    <h3>
        What&#39;s new in 0.1</h3>
    <ul>
        <li>Initial release. Includes publishing to FLAC format only.</li>
    </ul>
    <h3>Thanks for participating in this experiment!</h3>
    The point of this experiment is to answer this question: Can we empower
    non-technical users to do their own scripture recording if we build an
    application designed specifically for them?<p>
        At the moment, we break that into the following parts:</p>
    1) What are the usability hurdles such an application would need to address?<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"><UsingTask TaskName="StampAssemblies" AssemblyFile="$(teamcity_build_checkoutDir)/build/Palaso.BuildTasks.dll" /><UsingTask TaskName="MakeWixForDirTree" AssemblyFile="$(teamcity_build_checkoutDir)/build/Palaso.BuildTasks.dll" /><UsingTask TaskName="Split" AssemblyFile="$(teamcity_build_checkoutDir)/build/Palaso.BuildTasks.dll" /><UsingTask TaskName="FileUpdate" AssemblyFile="$(teamcity_build_checkoutDir)/build/Palaso.BuildTasks.dll" /><UsingTask TaskName="NUnitTeamCity" AssemblyFile="$(teamcity_dotnet_nunitlauncher_msbuild_task)"/><Target Name="VersionNumbers"><Message Text="BUILD_NUMBER: $(BUILD_NUMBER)" Importance="high"/><Split Input="$(BUILD_NUMBER)" Delimiter="." OutputSubString="2"><Output TaskParameter="ReturnValue" PropertyName="BuildCounter" /></Split><Message Text="BuildCounter: $(BuildCounter)" Importance="high"/><!-- Note, after some thought, we've decided this is the best place to keep the version number (not on TeamCity, not in the assemblies).     --><CreateProperty Value="0.2.$(BuildCounter)"><Output PropertyName="Version" TaskParameter="Value"/></CreateProperty><Message Text="Version: $(Version)" Importance="high"/></Target><Target Name="SetAssemblyVersion" DependsOnTargets="VersionNumbers"><ItemGroup><AssemblyInfoFiles Include="$(teamcity_build_checkoutDir)/src/**/assemblyinfo.cs"/></ItemGroup><StampAssemblies Version="$(Version)" InputAssemblyPaths="@(AssemblyInfoFiles)" /></Target><Target Name="Build" DependsOnTargets="SetAssemblyVersion"><MSBuild Projects="$(teamcity_build_checkoutDir)/HearThisVS2010.sln"
             Targets="Rebuild"
             Properties="Configuration=Release" /><Message Text="Build Complete"/></Target><Target Name="Test" DependsOnTargets ="Build"><ItemGroup><TestAssemblies Include="$(teamcity_build_checkoutDir)/output/release/*Tests.dll;"  /></ItemGroup><NUnitTeamCity Assemblies="@(TestAssemblies)" ExcludeCategory="SkipOnTeamCity" /></Target><Target Name="MakeDownloadPointers" DependsOnTargets="VersionNumbers" ><!-- copy it so we aren't modifying the original, which then is a pain on dev machines --><Copy SourceFiles ="$(teamcity_build_checkoutDir)\src\Installer\DownloadPointers.htm"
           DestinationFolder ="$(teamcity_build_checkoutDir)\output\Installer"/><!-- replace some parts of the file with the version number & date --><FileUpdate File="$(teamcity_build_checkoutDir)\output\Installer\DownloadPointers.htm"
                 DatePlaceholder='DEV_RELEASE_DATE'
                Regex='DEV_VERSION_NUMBER'
                 ReplacementText ="$(Version)" /><!-- push up to the web so that on our downloads page, we can give a link to the latest version --><Message Text="Attempting rsync of DownloadPointers.htm" Importance="high"/><Exec Command ='"c:\program files\cwRsync\bin\rsync.exe" -vz -p --chmod=ug+rw -e"\"c:\program files\cwRsync\bin\ssh\" -oUserKnownHostsFile=C:\BuildAgent\conf\known_hosts -oIdentityFile=C:\BuildAgent\conf\bob.key -l bob"  "../output/installer/DownloadPointers.htm" bob@palaso.org:/var/www/virtual/palaso.org/hearthis/htdocs/files/DownloadPointers.htm' /></Target><Target Name="Upload" DependsOnTargets="VersionNumbers; Installer" ><Message Text="Attempting rsync of HearThisInstaller-$(Version).msi" Importance="high"/><Exec Command ='"c:\program files\cwRsync\bin\rsync.exe" -vz -p --chmod=ug+rw -e"\"c:\program files\cwRsync\bin\ssh\" -oUserKnownHostsFile=C:\BuildAgent\conf\known_hosts -oIdentityFile=C:\BuildAgent\conf\bob.key -l bob"  "../output/installer/HearThisInstaller-$(Version).msi" bob@palaso.org:/var/www/virtual/palaso.org/hearthis/htdocs/files/HearThisInstaller-$(Version).msi' /><CallTarget Targets ='MakeDownloadPointers'/></Target><Target Name="Installer" DependsOnTargets="VersionNumbers; MakeWixForDistFiles; Build "><!-- set the version number in the installer configuration program.  Perhaps there's a way to just send in the variables rather than this brute-force
    changing of the script, but I haven't figured that out. --><FileUpdate File="$(teamcity_build_checkoutDir)\src\Installer\Installer.wxs" Regex='Property_ProductVersion = ".*"'
                ReplacementText ="Property_ProductVersion = &quot;$(Version)&quot;" /><Message Text="Making Installer Version: $(Version)" Importance="high"  /><MSBuild Projects="$(teamcity_build_checkoutDir)\src\Installer\Installer.wixproj"/><!-- remove an existing one with the same name, if necessary --><Delete Files="$(teamcity_build_checkoutDir)\output\installer\HearThisInstaller-$(Version).msi" TreatErrorsAsWarnings="false" /><Copy SourceFiles="$(teamcity_build_checkoutDir)\output\installer\HearThisInstaller.msi"
          DestinationFiles="$(teamcity_build_checkoutDir)\output\installer\HearThisInstaller-$(Version).msi"
          /><!-- remove the installer which has no version number (wouldn't need this if the copy above was a move, instead) --><Delete Files="$(teamcity_build_checkoutDir)\output\installer\HearThisInstaller.msi" TreatErrorsAsWarnings="false" /></Target><Target Name="MakeWixForDistFiles"><MakeDir Directories ="$(teamcity_build_checkoutDir)\output\installer" ContinueOnError ="true"/><MakeWixForDirTree
                DirectoryReferenceId="ProgramDir"
								ComponentGroupId="DistFiles"
                RootDirectory="$(teamcity_build_checkoutDir)\DistFiles"
                OutputFilePath="$(teamcity_build_checkoutDir)\output\Installer\GeneratedDistFiles.wxs"
                MatchRegExPattern=".*"
        ><!--what does this do?--><Output TaskParameter="OutputFilePath" ItemName="Compile" /></MakeWixForDirTree></Target></Project><br />
    2) What are the output quality issues such an application would need to address?<br />
    3) How much training is required for non-technical users?<br />
    4) What would it cost to build and deploy such an app (I&#39;m answering that,
    internally).<br/>

<h3>How to participate</h3>
    <p>1) Set up a headset microphone and (probably) an external A/D USB converter.&nbsp;
        Reportedly some laptops can do an OK recording job right out of the microphone
        jack, so if you can&#39;t locate an external convert, please do some experimenting
        anyways.</p>
    <p>2) Install Paratext, and get a project with some translated scripture on it.&nbsp;
        If you want to just use English, that&#39;s fine too. Currently SayMore hides most
        resource texts, but you are allowed to choose &quot;GNTUK&quot; if you have that resource
        installed.</p>
    <p>3) Either try it yourself, or if possible, get a non-technical native speaker to
        record for a while in his/her own language. Teach them to find a text, record
        each script item, check their recording, and re-record as necessary. After they
        get the basics, please teach them to use the keyboard, not the mouse (which is
        inefficient for such a repetitive task). Please take note of their reading
        fluency; a large proportion of the intended audience will struggle to read
        naturally, and that&#39;s why the interface is designed to make it easy to listen
        and re-record, as many times as necessary.&nbsp; So it would help to hear
        results from people with a range of reading abilities.</p>
    <p><a href="mailto:4)%20Send%20me%20(hattonjohn@gmail.com">4) Send me
        (hattonjohn@gmail.com</a>) your results:</p>
    <ol>
        <li>In what country did you do the test?</li>
        <li>What language did you try?</li>
        <li>&nbsp;How long did it take to train yourself or someone else? </li>
        <li>Are there any parts of HearThis that you particularly like?</li>
        <li>Are there parts that you don&#39;t like? Parts that are difficult? </li>
        <li>How would you characterize the quality of the resulting recordings?</li>
        <li>If you have done recordings in more traditional ways, how would you characterize
            the two approaches?</li>
        <li>What the pros/cons do you see?</li>
        <li>If this were a completed product, would you recommend its use to your entity?</li>
    </ol>
    <h3>What kinds of problems to report</h3>
    <p>
        Note: Since this is an experiment, and not a polished product, there are dozens
        of&nbsp; rough edges and missing features.&nbsp; I am trying to limit the app to
        just what we need to answer the experiments questions.&nbsp; Then, if we
        determine that such an app would make a big difference, we can move into
        production mode as programming resources become available.</p>
    <p>
        Please report those problems which interfere with doing the experiment.&nbsp;
        For example, if you notice that a final quote mark is missing, you only need to
        report that if it seemed to be a roadblock for the reader.&nbsp; If you notice
        that the font doesn&#39;t match Paratext, but this isn&#39;t interfering with the
        experiment, then don&#39;t bother reporting it at this time.</p>

<h3>Important features that are missing</h3>
    <ol>
        <li>The display of books and chapters is currently only a binary thing: gray if it
            has at least one verse, otherwise light gray. What we would eventually want is
            blue=has been recorded.&nbsp; We would also like to get an indication if the
            book/chapter in question is fully or partially translated, and fully or
            partially recorded. There are other visual/interaction improvements that are
            yearning to be done in this area.</li>
        <li>There may need to be a control for choosing how big a chunk each script line
            should be: Paragraph? Verse? Sentence?&nbsp; Currently, you always get a
            sentence.</li>
        <li>It would probably help to split out book introduction material (everything that
            comes before the first chapter) into it&#39;s own &quot;chapter&quot; group (e.g. chapter 0
            would be the book intro). Currently, this material just shows up as part of
            chapter 1.</li>
        <li>Some sort of review workflow, in which a reviewer can listen and mark which
            verses have problems and need to be re-recorded. Then there would be an easy way
            for the narrator to find those spots and re-record.</li>
        <li>Auto record the audio &quot;tag files&quot; used by MegaVoice for navigation</li>
        <li>Help with setting up and testing the recording equipment and levels.</li>
        <li>While most of the script text comes from the Paratext files themselves, a few
            words, like &quot;Chapter&quot; are always in English.&nbsp; There will need to be a
            editable small list of such words in the vernacular.</li>
    </ol>
    <h3>
        Under the hood</h3>
    <p>
        HearThis stores a separate WAV file for each script line, indefinetly.&nbsp;
        When you &quot;Publish&quot;, it gathers these up, joins them into chapters, and then
        converts them to the format you choose.&nbsp;&nbsp; The individual WAV files are
        stored in the Program Data folder, under the SIL\HearThis directory.&nbsp; For
        example, on Windows 7, Genesis chapter 1 of the Good News UK would be stored
        here: <a href="file:///C:/ProgramData/SIL/HearThis/GNTUK/Genesis/1">
        C:\ProgramData\SIL\HearThis\GNTUK\Genesis\1</a>.&nbsp; This location needs to be
        backed up (a future version of MyWorkSafe will do that automatically). If for
        some reason you need to get at these files, for example to delete them or run
        some audio cleanup process over them, feel free to do so.</p>
    <h3>
        Notes on Publishing</h3>
    <p>
        To publish in mp3 format, you&#39;ll need to download something extra. MP3 is
        patented, so we can&#39;t just include an encoder in HearThis without infringing on
        patents in some countries. If you install &quot;<a
            href="http://audacity.sourceforge.net/help/faq?s=install&amp;item=lame-mp3">LAME
        for Audacity</a>&quot;, then HearThis will use it to create MP3s.&nbsp; This
        format is also needed for publishing to Saber devices.</p>
    <h3>
        Notes on MegaVoice</h3>
    <p>
        MegaVoice uses small &quot;tag&quot; recordings to help the user navigate by audio.&nbsp;
        This version of HearThis does not yet generate those files.&nbsp; MegaVoice also
        requires a particular bit/rate for its wav files (16bit, 44.1k, mono).&nbsp; HearThis does convert
        the recorded files to that format, if necessary.</p>
</body>
</html>